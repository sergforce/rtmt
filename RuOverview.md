# Обзор #
RTMT система сбора данных и измерений интервалов реального времени. Принцип прост: исследуемый код обрамляется специальными макросами, которые сохраняют временные метки в оперативную память. Во время сбора идет работа только с предварительно выделенной оперативной памятью. По окончанию сбора данных набранная статистика сбрасывается в файл.
## Храрактеристики ##
В текущей версии есть 2 метода получения времени:
  1. gettimeofday(). Из плюсов работает всегда, иногда высокая цена вызова для измерений (около микросекунды на современных процессорах)
  1. использование процессорного счетчика (http://en.wikipedia.org/wiki/Time_Stamp_Counter). Из плюсов наименьшие дополнительные накладные расходы, из минусов не на всех процессорах данный метод надежен. Фактический некоторые процессоры могут управлять своей частотой и это приводит к неравномерному счету, однако в последних процессорах TSC счетчик всегда работает на максимальной частоте не зависимо от реальной текущей. Чтобы убедится, что процессор с динамическим управлением частотой, производит счет на постоянной скорости должен быть установлен флаг constant\_tsc в cat /proc/cpuinfo. Типичные расходы при этом случае составляют около 50нс.

По умолчанию используется второй метод.

# Использование #
## Добавление меток ##
Пример использования в простой программе, которая замеряет время выполнения вызова gettimeofday:
```

#include <stdio.h>
#include <stdint.h>
#include <sys/time.h>
#include "RTMD.h"

int main(int argc, char** argv)
{
    struct timeval tv;
    int i;

    RTMD_INIT(10000);

    for (i = 0; i < 10; i++)
    {
        RTMD_SET("gettimeofday");
        gettimeofday(&tv, NULL);
        RTMD_CLEAR("gettimeofday");
    }

    RTMD_FLUSH("test2.rtmd");
    return 0;
}
```

  * Строка 4 - заголовочный файл "RTMD.h"
  * Строка 11 - инициализирование хранилища на 10000 меток
  * Строка 15 - начало замера события в ячейку "gettimeofday"
  * Строка 17 - конец замера события в ячейку "gettimeofday"
  * Строка 20 - сброс намеренных значений в test2.rtmd

При компилировании программы также необходимо включить RTMD.c в проект и объявить WITH\_RTMD.

## Разбор данных ##
Для постройки графиков и просмотра информации в текстовом виде служит утилита ''rtmdplot.py''.

```
serg@lis:/anyproject> ./rtmdplot.py test2.rtmd 
Resolution  0.322 nsec
Start rec: 2011-03-02 16:24:40.378266
Penalty    53.7 nsec (166 clocks)
Shifting gettimeofday
Mkdir test2
LINESTYLE=with linespoints
Duration [0.000058:0.000066]  (0.000009 sec)

        gettimeofday:     20 items  ymin=   0 ymax=   1          start=0.000000  stop=0.000009  style=tdiffms
```

В процессе разбора выводится некоторая полезная информация:
  * Penalty     53.7 nsec  - время, затрачиваемое на саму операцию замера времени и складирование результата
  * Start rec:  Время вызова RTMD\_INIT()
  * Duration [0.000058:0.000066]  (0.000009 sec)   период появления полезных меток, относительно времени вызова RTMD\_INIT()
  * списки найденных ячеек и количество меток

При этом в папке test2 создаются файлы данных и график, а также csv-файл всех меток, который можно использовать для последующих обработок. Пример такого файла:
```
Start 2011-03-02 16:24:40.378323 (delta in us),gettimeofday
0.000,0.959,
1.044,0.796,
1.902,0.796,
2.753,0.796,
3.601,0.799,
4.452,0.799,
5.304,0.799,
6.155,0.796,
7.006,0.796,
7.855,0.799,
```
Первый столбец это время RTMD\_SET относительно начала записи (2011-03-02 16:24:40.378323) в микросекундах, второй столбец это разница между временами RTMD\_CLEAR("gettimeofday") - RTMD\_SET("gettimeofday"). Таким образом можно сделать вывод что вызов gettimeofday на данной платформе занимает около 0.8 мкс.

## API ##
```
/* Инициализация хранилища на max элементов */
void RTMD_INIT(unsigned max);
/* Сброс накопленных данных в файл filename */
void RTMD_FLUSH(const char* filename);

/* Занесение в ячейку var временной метки со значением value */
void RTMD_VAL(const char* var, int value);

/* Аналогично RTMD_VAL(var, 1) -- служит для признака начала измерения временного интервала */
void RTMD_SET(const char* var);
/* Аналогично RTMD_VAL(var, 0) -- служит для признака конца измерения временного интервала */
void RTMD_CLEAR(const char* var);

/* Данные вызовы аналогичены RTMD_SET и RTMD_CLEAR, однако, в качестве временной метки используется значение tv. Полезен в тех случаях где в самой программе уже есть вызовы gettimeofday(), чтобы сократить накладные расходы. ПРИМЕЧАНИЕ: Указывание значение из далекого прошлого и будущего относительно реального времени может нарушить работу программы trmdplot */
void RTMD_SETTIME(const char* name, const struct timeval *tv);
void RTMD_CLEARTIME(const char* name, const struct timeval *tv);
```

|Макрос|Назначение|
|:-----------|:-------------------|
|WITH\_RTMD|Включает механизм RTMD. Нужно объявлять всегда, когда используется RTMD. Если не объявлять то метки не будут иметь никакого значения |
|NO\_RTMD|Служит для избирательного исключения механизма RTMD в отдельном файле, обычно объявляется перед #include "RTMD.h"|
|NO\_CYCLE|Отключить механизм считывания счетчиков CPU и использовать gettimeofday() для определения меток|
|RTMD\_THREAD\_SAFE|Использовать в многопоточной программе, гарантирует правильное сохранение данных|
|RTMD\_SAFE\_ALIGN|Использовать безопасное сохранение метки, имеет смысл только на RISC машинах которые критичны к выравниванию|

## rtmdplot ##
Использование
```
rtmdplot.py [--dots|--cross|--merge|--le|--be] filename [filename2] [variable=imp|tdiffms|none]
```
  * --le Разбирать файл, снятой, на машине с Little-Endian архитектурой (x86, x86\_64)
  * --be Разбирать файл, снятой, на машине с Big-Endian архитектурой    (hppa)
> Если не указывать правило разбора то будет использоваться типичная для данной машины представление

  * --dots Графики строить токо точками
  * --cross Графики строить токо крестиками
  * --stat-all Рассчитать статистику по всем переменным и нарисовать гистограммы распредления значения
  * --stat=name1,name2  Рассчитать статистику только по переменным или группировке переменных name1,name2

  * --merge Опция слияния двух файлов, например когда измерения отправляющий стороны были в одном процессе, а принимающей в другом. Слияния будет происходить по имени ячейки.

> Также можно указывать тип интерпретирования ячейки:
    * imp Рисовать как импульсное значение (тоесть точки не соединять между собой, а только рисовать вертикальные линии обозначающие значения)
    * tdiffms Рассчитать дельты между замерами RTMD\_SET и RTMD\_CLEAR, построить данную разницу в момент RTMD\_SET. Кроме того данный параметр позволяет ограничивать область максимльной дельты, чтобы выбросы не ухудшали масштаб. Размер максимального значения указывается через двоеточие в миллисекундах, например tdiffms:0.1 или tdiffms:20

Пример сложной команды:
```
./rtmdplot.py --cross tsmrserv.19244.rtmd Recv=tdiffms:5 send=tdiffms:0.03 msgrcv=tdiffms:3 msgsnd=tdiffms:0.01
```
и результат: [[attachment:tsmrserv.19244.csv]]

{{attachment:tsmrserv.19244.png}}



# Производительность #
Накладные расходы на разных платформах с разными опциями компиляции

| Тип | PA-RISC  | Intel x86\_64 (Core(TM)2 Duo  E8500  @ 3.16GHz) |
|:-------|:---------|:------------------------------------------------|
| Resolution |  1.365 nsec  (732.6 Mhz) | Resolution  0.315 nsec  (3170.3 Mhz) |
| без оптимизаций | 116.9 nsec (86 clocks) | Penalty    39.0 nsec (122 clocks) |
| с O2 | 68.5 nsec (50 clocks) | Penalty    22.2 nsec (70 clocks) |
| вызов gettimeofday(), мкс |  2.044  | 0.754 |